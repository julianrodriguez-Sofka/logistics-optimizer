#!/usr/bin/env node/** * OpenRouteService MCP Server * FREE alternative to Google Maps - No credit card required! *  * This Model Context Protocol server provides tools for interacting with OpenRouteService API: * - Calculate routes between two locations * - Geocode addresses to coordinates * - Get distance and duration information * - Support for multiple travel modes *  * Limits: 2000 requests/day (Free tier) *  * Tools provided: * - calculate_route: Calculate route between origin and destination * - geocode_address: Convert address to coordinates * - reverse_geocode: Convert coordinates to address */import { Server } from '@modelcontextprotocol/sdk/server/index.js';import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';import {  CallToolRequestSchema,  ListToolsRequestSchema,  Tool,} from '@modelcontextprotocol/sdk/types.js';import axios from 'axios';import * as dotenv from 'dotenv';// Load environment variablesdotenv.config();const OPENROUTESERVICE_API_KEY = process.env.OPENROUTESERVICE_API_KEY;const BASE_URL = 'https://api.openrouteservice.org';if (!OPENROUTESERVICE_API_KEY || OPENROUTESERVICE_API_KEY === 'your_openrouteservice_api_key_here') {  console.error('‚ùå OPENROUTESERVICE_API_KEY is not configured in .env file');  console.error('   Please get a free API key at: https://openrouteservice.org/dev/#/signup');  console.error('   No credit card required - 2000 requests/day free!');  process.exit(1);}// Cache for geocoding resultsconst geocodeCache = new Map<string, { lat: number; lng: number; formattedAddress: string }>();/** * Define tools available in this MCP server */const TOOLS: Tool[] = [  {    name: 'calculate_route',    description: 'Calculate a route between two locations using OpenRouteService Directions API. Returns distance, duration, and route information. FREE - No credit card required.',    inputSchema: {      type: 'object',      properties: {        origin: {          type: 'string',          description: 'Starting location (address or coordinates)',        },        destination: {          type: 'string',          description: 'Destination location (address or coordinates)',        },        mode: {          type: 'string',          enum: ['driving-car', 'driving-hgv', 'cycling-regular', 'foot-walking'],          description: 'Travel mode (default: driving-car)',        },      },      required: ['origin', 'destination'],    },  },  {    name: 'geocode_address',    description: 'Convert an address to geographic coordinates (latitude/longitude) using OpenRouteService Geocoding API. FREE service.',    inputSchema: {      type: 'object',      properties: {        address: {          type: 'string',          description: 'Address to geocode',        },      },      required: ['address'],    },  },  {    name: 'reverse_geocode',    description: 'Convert geographic coordinates to an address using OpenRouteService Reverse Geocoding API. FREE service.',    inputSchema: {      type: 'object',      properties: {        latitude: {          type: 'number',          description: 'Latitude coordinate',        },        longitude: {          type: 'number',          description: 'Longitude coordinate',        },      },      required: ['latitude', 'longitude'],    },  },];/** * Geocode an address to coordinates */async function geocodeAddress(address: string): Promise<{ lat: number; lng: number; formattedAddress: string }> {  const cacheKey = address.toLowerCase().trim();  if (geocodeCache.has(cacheKey)) {    return geocodeCache.get(cacheKey)!;  }  try {    const response = await axios.get(`${BASE_URL}/geocode/search`, {      params: {        api_key: OPENROUTESERVICE_API_KEY,        text: address,      },    });    if (!response.data.features || response.data.features.length === 0) {      throw new Error(`No results found for address: ${address}`);    }    const coords = response.data.features[0].geometry.coordinates;    const properties = response.data.features[0].properties;        const geocodedData = {      lng: coords[0],      lat: coords[1],      formattedAddress: properties.label || address,    };    geocodeCache.set(cacheKey, geocodedData);    return geocodedData;  } catch (error: any) {    throw new Error(`Geocoding failed: ${error.response?.data?.error?.message || error.message}`);  }}/** * Reverse geocode coordinates to address */async function reverseGeocode(lat: number, lng: number): Promise<string> {  try {    const response = await axios.get(`${BASE_URL}/geocode/reverse`, {      params: {        api_key: OPENROUTESERVICE_API_KEY,        'point.lon': lng,        'point.lat': lat,      },    });    if (!response.data.features || response.data.features.length === 0) {      throw new Error(`No address found for coordinates: ${lat}, ${lng}`);    }    return response.data.features[0].properties.label;  } catch (error: any) {    throw new Error(`Reverse geocoding failed: ${error.response?.data?.error?.message || error.message}`);  }}/** * Calculate route between two locations */async function calculateRoute(  origin: string,  destination: string,  mode: string = 'driving-car'): Promise<any> {  try {    // Geocode origin and destination    const originCoords = await geocodeAddress(origin);    const destCoords = await geocodeAddress(destination);    // Get directions    const response = await axios.post(      `${BASE_URL}/v2/directions/${mode}`,      {        coordinates: [          [originCoords.lng, originCoords.lat],          [destCoords.lng, destCoords.lat],        ],      },      {        headers: {          Authorization: OPENROUTESERVICE_API_KEY,          'Content-Type': 'application/json',        },      }    );    const route = response.data.routes[0];    const summary = route.summary;    return {      origin: {        address: originCoords.formattedAddress,        lat: originCoords.lat,        lng: originCoords.lng,      },      destination: {        address: destCoords.formattedAddress,        lat: destCoords.lat,        lng: destCoords.lng,      },      distance: {        meters: summary.distance,        kilometers: Math.round(summary.distance / 1000 * 100) / 100,        text: `${Math.round(summary.distance / 1000)} km`,      },      duration: {        seconds: summary.duration,        minutes: Math.round(summary.duration / 60),        text: `${Math.round(summary.duration / 60)} min`,      },      mode,    };  } catch (error: any) {    throw new Error(`Route calculation failed: ${error.response?.data?.error?.message || error.message}`);  }}/** * Create and configure the MCP server */const server = new Server(  {    name: 'openrouteservice-mcp',    version: '1.0.0',  },  {    capabilities: {      tools: {},    },  });/** * Handler for listing available tools */server.setRequestHandler(ListToolsRequestSchema, async () => {  return { tools: TOOLS };});/** * Handler for tool execution */server.setRequestHandler(CallToolRequestSchema, async (request) => {  const { name, arguments: args } = request.params;  try {    switch (name) {      case 'calculate_route': {        const { origin, destination, mode = 'driving-car' } = args as any;        const result = await calculateRoute(origin, destination, mode);        return {          content: [            {              type: 'text',              text: JSON.stringify(result, null, 2),            },          ],        };      }      case 'geocode_address': {        const { address } = args as any;        const result = await geocodeAddress(address);        return {          content: [            {              type: 'text',              text: JSON.stringify(result, null, 2),            },          ],        };      }      case 'reverse_geocode': {        const { latitude, longitude } = args as any;        const result = await reverseGeocode(latitude, longitude);        return {          content: [            {              type: 'text',              text: JSON.stringify({ address: result }, null, 2),            },          ],        };      }      default:        throw new Error(`Unknown tool: ${name}`);    }  } catch (error: any) {    return {      content: [        {          type: 'text',          text: JSON.stringify({ error: error.message }, null, 2),        },      ],      isError: true,    };  }});/** * Start the server */async function main() {  console.error('üó∫Ô∏è  OpenRouteService MCP Server starting...');  console.error('   üÜì FREE - No credit card required!');  console.error('   üìä Limit: 2000 requests/day');  console.error(`   API Key configured: ${OPENROUTESERVICE_API_KEY ? '‚úÖ Yes' : '‚ùå No'}`);  console.error('   Available tools:');  TOOLS.forEach((tool) => {    console.error(`   - ${tool.name}: ${tool.description}`);  });  const transport = new StdioServerTransport();  await server.connect(transport);  console.error('‚úÖ OpenRouteService MCP Server ready!');}main().catch((error) => {  console.error('‚ùå Fatal error:', error);  process.exit(1);});